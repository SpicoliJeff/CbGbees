<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>C Head On: C vs C++ Differences</title>
  <style>
    /* Minimalist grey/white theme inspired by original C logo */
    :root {
      --bg: #f0f0f0; /* Light grey background */
      --header-bg: #808080; /* Medium grey for headers */
      --code-bg: #d3d3d3; /* Light grey for code areas */
      --text: #000000; /* Black text for readability */
      --comment: #000000; /* Black for comments */
      --hint: #000000; /* Black for hints (changed to black) */
      --accent: #ffffff; /* White accents */
      --btn: #a9a9a9; /* Grey buttons */
      --btn-hover: #696969; /* Darker grey on hover */
      --border: #c0c0c0; /* Silver borders */
      --shine: #ffffff; /* White for shine effects */
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    header {
      background: var(--header-bg);
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 4px solid var(--border);
      position: relative;
      z-index: 10;
    }
    h1 { font-size: 22px; color: #ffffff; text-shadow: 0 0 10px #c0c0c0; } /* White title on grey */
    #chapter-btn {
      background: var(--btn);
      color: #fff;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
    }
    #chapter-btn:hover { background: var(--btn-hover); }
    #chapter-list {
      position: absolute;
      top: calc(100% + 10px);
      right: 0;
      background: var(--header-bg);
      border: 3px solid var(--border);
      border-radius: 10px;
      max-height: 65vh;
      overflow-y: auto;
      width: 340px;
      display: none;
      z-index: 1000;
      box-shadow: 0 15px 30px rgba(0,0,0,0.8);
    }
    #chapter-list.show { display: block; }
    .chapter-item {
      padding: 16px 20px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      font-size: 16px;
      color: #ffffff;
    }
    .chapter-item:hover { background: #696969; } /* Darker grey hover */
    #main { flex: 1; display: flex; flex-direction: column; }
    #code-area {
      flex: 1;
      background: var(--code-bg);
      padding: 20px 30px;
      overflow-y: auto;
      line-height: 1.5;
      font-size: 16px;
      white-space: pre;
      border-bottom: 4px solid var(--border);
    }
    .line { display: block; padding: 1px 0; color: #000000; } /* Black code text */
    .line.new { animation: addLine 0.8s ease-out; }
    .line.action-shine { background: #a9a9a9; animation: actionGlow 1s ease-in-out; }
    .line.line-shine { background: #696969; animation: lineGlow 1.8s ease-in-out; box-shadow: 0 0 40px #c0c0c0; }
    @keyframes addLine { 0% { opacity: 0; transform: translateY(20px); } 100% { opacity: 1; transform: translateY(0); } }
    @keyframes actionGlow { 0%,100% { background: var(--code-bg); } 50% { background: #a9a9a9; } }
    @keyframes lineGlow { 0%,100% { background: var(--code-bg); } 50% { background: #808080; box-shadow: 0 0 60px #c0c0c0; } }
    #comment-box {
      background: var(--header-bg);
      color: var(--comment);
      padding: 25px 30px;
      font-size: 19px;
      border-top: 4px solid var(--border);
      min-height: 110px;
      line-height: 1.7;
    }
    #hint-area {
      background: var(--bg);
      padding: 16px 25px;
      font-size: 17px;
      color: var(--hint); /* Now black for "Type exactly:" */
      font-weight: bold;
      border-top: 4px solid var(--border);
    }
    #input-area {
      background: var(--header-bg);
      padding: 20px 25px;
      border-top: 4px solid var(--border);
      display: flex;
      gap: 15px;
      align-items: center;
    }
    #code-input {
      flex: 1;
      background: var(--code-bg);
      color: var(--text);
      border: 4px solid var(--border);
      padding: 16px;
      font-family: 'Courier New', monospace;
      font-size: 19px;
      border-radius: 10px;
    }
    #code-input:focus { outline: none; border-color: #c0c0c0; box-shadow: 0 0 25px #c0c0c0; }
    #code-input::placeholder { color: var(--comment); opacity: 1; transition: opacity 0.6s ease; }
    #code-input.fade::placeholder { opacity: 0; }
    #submit-btn, #skip-btn {
      border: none;
      padding: 16px 25px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 17px;
      box-shadow: 0 5px 12px rgba(0,0,0,0.7);
    }
    #submit-btn { background: var(--btn); color: #fff; }
    #submit-btn:hover { background: var(--btn-hover); }
    #skip-btn { background: #a9a9a9; color: white; } /* Grey skip */
    #skip-btn:hover { background: #696969; }
    #controls {
      background: var(--bg);
      padding: 16px;
      display: flex;
      justify-content: center;
      gap: 18px;
      border-top: 4px solid var(--border);
    }
    button {
      background: var(--btn);
      color: #fff;
      border: none;
      padding: 14px 25px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 5px 12px rgba(0,0,0,0.7);
    }
    button:hover:not(:disabled) { background: var(--btn-hover); }
    button:disabled { background: #c0c0c0; cursor: not-allowed; }
  </style>
</head>
<body>
<header>
  <h1>C Head On: C vs C++ Differences</h1>
  <div id="chapter-selector">
    <button id="chapter-btn">Select Chapter</button>
    <div id="chapter-list"></div>
  </div>
</header>
<div id="main">
  <div id="code-area"></div>
  <div id="comment-box"></div>
  <div id="hint-area">Type exactly:</div>
  <div id="input-area">
    <input type="text" id="code-input" autocomplete="off" />
    <button id="submit-btn">Submit</button>
    <button id="skip-btn">Skip</button>
  </div>
  <div id="controls">
    <button id="prev">Previous</button>
    <button id="next" disabled>Next</button>
    <button id="reset">Reset</button>
  </div>
</div>
<script>
  let chapters = [
    {
  "title": "CHAPTER 1: Default Function Linkage in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: In C, functions have simple external names without mangling, making linking straightforward but no overloading support. In C++, name mangling encodes types for overloading, but requires extern \"C\" for C compatibility. Impact: Critical for mixed-language projects; prevents linker errors.", "code": "" },
    { "comment": "// myfunc.c — This is a C source file. In C, functions have external linkage by default and simple names (no mangling).", "code": "// myfunc.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// void my_func(int x) { — Defines a function named my_func that takes one integer parameter.", "code": "void my_func(int x) {" },
    { "comment": "// printf(\"%d\\n\", x); — Prints the integer value passed into the function, followed by a newline.", "code": " printf(\"%d\\n\", x);" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// my_func(42); — Calls our function with the integer 42 as an argument.", "code": " my_func(42);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Note: When compiled with gcc, the symbol name remains simple (e.g., _my_func) because C does not mangle names.", "code": "" },
    { "comment": "// myfunc.cpp — This is a C++ source file. In C++, functions use name mangling to support overloading.", "code": "// myfunc.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// void my_func(int x) { — Defines a function with the same signature as in C, but internally the compiler mangles the name.", "code": "void my_func(int x) {" },
    { "comment": "// std::cout << x << \"\\n\"; — Prints the integer value using C++ streams, followed by a newline.", "code": " std::cout << x << \"\\n\";" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// my_func(42); — Calls our function with the integer 42 as an argument.", "code": " my_func(42);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Practical Impact: Because of name mangling, the symbol name in compiled C++ code is more complex. To make it compatible with C, use extern \"C\".", "code": "/* extern \"C\" void my_func(int x); */" }
  ]
},
    {
  "title": "CHAPTER 2: Function Overloading in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C does not support overloading, requiring unique names for similar functions. C++ allows overloading based on parameters, enabling cleaner APIs. Impact: Reduces naming clutter in C++; compiler resolves calls. Nuances: Can cause ambiguity.", "code": "" },
    { "comment": "// myfunc_overload.c — This is a C source file. In C, function overloading is not supported, so each function must have a unique name.", "code": "// myfunc_overload.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// void print_int(int x) { — Defines a function specifically for printing integers.", "code": "void print_int(int x) {" },
    { "comment": "// printf(\"%d\\n\", x); — Prints the integer value passed into the function, followed by a newline.", "code": " printf(\"%d\\n\", x);" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// void print_double(double x) { — Defines a separate function specifically for printing doubles.", "code": "void print_double(double x) {" },
    { "comment": "// printf(\"%f\\n\", x); — Prints the double value passed into the function, followed by a newline.", "code": " printf(\"%f\\n\", x);" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// print_int(42); — Calls the integer-specific function with an integer argument.", "code": " print_int(42);" },
    { "comment": "// print_double(3.14); — Calls the double-specific function with a double argument.", "code": " print_double(3.14);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myfunc_overload.cpp — This is a C++ source file. In C++, function overloading is supported, allowing multiple functions with the same name but different parameters.", "code": "// myfunc_overload.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// void print(int x) { — Defines an overload of print for integer parameters.", "code": "void print(int x) {" },
    { "comment": "// std::cout << x << \"\\n\"; — Prints the integer value using C++ streams, followed by a newline.", "code": " std::cout << x << \"\\n\";" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// void print(double x) { — Defines another overload of print for double parameters.", "code": "void print(double x) {" },
    { "comment": "// std::cout << x << \"\\n\"; — Prints the double value using C++ streams, followed by a newline.", "code": " std::cout << x << \"\\n\";" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// print(42); — Calls the integer overload based on argument type.", "code": " print(42);" },
    { "comment": "// print(3.14); — Calls the double overload based on argument type.", "code": " print(3.14);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C requires unique names for different types, leading to verbose APIs. C++ overloading enables cleaner code; the compiler resolves the correct function based on arguments. Nuances: Overloading can cause ambiguity if signatures are too similar.", "code": "/* Call: print(42); print(3.14); */" }
  ]
},
    {
  "title": "CHAPTER 3: Default Arguments in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C requires all arguments explicitly; no defaults. C++ allows default parameters for flexibility. Impact: Cleaner calls in C++; optional args. Nuances: Defaults in declarations only.", "code": "" },
    { "comment": "// myfunc_defaults.c — This is a C source file. In C, functions do not support default arguments; all parameters must be provided explicitly.", "code": "// myfunc_defaults.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// void func(int x, int y) { — Defines a function that requires two integer parameters.", "code": "void func(int x, int y) {" },
    { "comment": "// printf(\"%d %d\\n\", x, y); — Prints the values of both parameters, followed by a newline.", "code": " printf(\"%d %d\\n\", x, y);" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(1, 2); — Calls the function with both arguments explicitly provided.", "code": " func(1, 2);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myfunc_defaults.cpp — This is a C++ source file. In C++, functions can have default arguments.", "code": "// myfunc_defaults.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// void func(int x, int y = 0) { — Defines a function with a default value of 0 for y.", "code": "void func(int x, int y = 0) {" },
    { "comment": "// std::cout << x << \" \" << y << \"\\n\"; — Prints the values of x and y (using default if not provided), followed by a newline.", "code": " std::cout << x << \" \" << y << \"\\n\";" },
    { "comment": "// } — Marks the end of the function definition.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(1); — Calls the function with only x; y uses default value 0.", "code": " func(1);" },
    { "comment": "// func(1, 2); — Calls the function with both arguments; overrides default.", "code": " func(1, 2);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C requires all arguments, leading to repetitive code. C++ defaults enable flexible APIs. Nuances: Defaults must be in declarations (headers); redeclaring can cause linker errors. Implications: Improves usability but requires careful header management.", "code": "/* Add defaults in headers only. */" }
  ]
},
    {
  "title": "CHAPTER 4: struct vs class in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C only has struct with public members. C++ adds class with private default for encapsulation. Impact: Better data hiding in C++. Nuances: struct public in C++.", "code": "" },
    { "comment": "// mystruct.c — This is a C source file. In C, only struct exists, and all members are public by default.", "code": "// mystruct.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// struct Point { int x, y; }; — Defines a struct with two public integer members.", "code": "struct Point { int x, y; };" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p; — Declares a struct variable.", "code": " struct Point p;" },
    { "comment": "// p.x = 1; p.y = 2; — Directly assigns to members since they are public.", "code": " p.x = 1; p.y = 2;" },
    { "comment": "// printf(\"%d %d\\n\", p.x, p.y); — Prints member values.", "code": " printf(\"%d %d\\n\", p.x, p.y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myclass.cpp — This is a C++ source file. In C++, class defaults to private members, while struct defaults to public.", "code": "// myclass.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// class Point { private: int x, y; — Defines a class with private members by default.", "code": "class Point { private: int x, y;" },
    { "comment": "// public: void set(int a, int b) { x = a; y = b; } — Public method for controlled access to private data.", "code": " public: void set(int a, int b) { x = a; y = b; }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// Point p; — Declares a class variable.", "code": " Point p;" },
    { "comment": "// p.set(1, 2); — Uses public method to set private members.", "code": " p.set(1, 2);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C structs are simple with public members. C++ classes enable encapsulation. Nuances: Use struct for public POD; class for private data. Implications: Better data hiding in C++, but requires methods for access.", "code": "/* Use struct for POD types. */" }
  ]
},
    {
  "title": "CHAPTER 5: Member Functions in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C uses free functions separate from structs. C++ member functions tied to classes. Impact: OOP in C++; better organization. Nuances: Implicit 'this' in C++.", "code": "" },
    { "comment": "// mymember.c — This is a C source file. In C, structs cannot contain functions; they must be separate.", "code": "// mymember.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// struct Point { int x, y; }; — Defines a struct with two public integer members.", "code": "struct Point { int x, y; };" },
    { "comment": "// void set(struct Point* p, int a, int b) { p->x = a; p->y = b; } — Separate function to modify struct.", "code": "void set(struct Point* p, int a, int b) { p->x = a; p->y = b; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p; — Declares a struct variable.", "code": " struct Point p;" },
    { "comment": "// set(&p, 1, 2); — Calls separate function with pointer to struct.", "code": " set(&p, 1, 2);" },
    { "comment": "// printf(\"%d %d\\n\", p.x, p.y); — Prints modified members.", "code": " printf(\"%d %d\\n\", p.x, p.y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mymember.cpp — This is a C++ source file. In C++, classes can contain member functions.", "code": "// mymember.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// class Point { int x, y; — Defines a class with private members by default.", "code": "class Point { int x, y;" },
    { "comment": "// public: void set(int a, int b) { x = a; y = b; } — Member function for setting values.", "code": " public: void set(int a, int b) { x = a; y = b; }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// Point p; — Declares a class variable.", "code": " Point p;" },
    { "comment": "// p.set(1, 2); — Calls member function directly on object.", "code": " p.set(1, 2);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C requires separate functions. C++ member functions encapsulate behavior. Nuances: Implicit 'this' in C++. Implications: Better organization, but inheritance adds complexity.", "code": "/* Call: Point p; p.set(1,2); */" }
  ]
},
    {
  "title": "CHAPTER 6: this Pointer in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C requires explicit pointers for self-reference. C++ provides implicit 'this' in methods. Impact: Cleaner syntax in C++. Nuances: 'this' for disambiguation.", "code": "" },
    { "comment": "// mythis.c — This is a C source file. In C, to simulate 'this', you pass an explicit pointer.", "code": "// mythis.c" },
    { "comment": "// #include <stdio.h> — Includes the standard I/O library so we can use printf for output.", "code": "#include <stdio.h>" },
    { "comment": "// struct Point { int x, y; }; — Defines a struct with two public integer members.", "code": "struct Point { int x, y; };" },
    { "comment": "// void set(struct Point* self, int a, int b) { self->x = a; self->y = b; } — Explicit pointer 'self'.", "code": "void set(struct Point* self, int a, int b) { self->x = a; self->y = b; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p; — Declares a struct variable.", "code": " struct Point p;" },
    { "comment": "// set(&p, 1, 2); — Passes address explicitly as 'self'.", "code": " set(&p, 1, 2);" },
    { "comment": "// printf(\"%d %d\\n\", p.x, p.y); — Prints modified members.", "code": " printf(\"%d %d\\n\", p.x, p.y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mythis.cpp — This is a C++ source file. In C++, 'this' is an implicit pointer in member functions.", "code": "// mythis.cpp" },
    { "comment": "// #include <iostream> — Includes the C++ I/O stream library so we can use std::cout for output.", "code": "#include <iostream>" },
    { "comment": "// class Point { int x, y; — Defines a class with private members by default.", "code": "class Point { int x, y;" },
    { "comment": "// public: void set(int a, int b) { this->x = a; this->y = b; } — Implicit 'this' pointer.", "code": " public: void set(int a, int b) { this->x = a; this->y = b; }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// Point p; — Declares a class variable.", "code": " Point p;" },
    { "comment": "// p.set(1, 2); — 'this' implicitly points to p.", "code": " p.set(1, 2);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C requires explicit pointers. C++ 'this' simplifies syntax. Nuances: Use for disambiguation. Implications: Reduces errors, but 'this' can be null in edge cases.", "code": "/* Use this for disambiguation. */" }
  ]
},
    {
  "title": "CHAPTER 7: Constructor / Destructor in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual init/cleanup via functions. C++ auto via ctor/dtor. Impact: RAII in C++; leak prevention. Nuances: Init lists.", "code": "" },
    { "comment": "// myctor.c — This is a C source file. In C, structs have no constructors/destructors; manual init/cleanup.", "code": "// myctor.c" },
    { "comment": "// #include <stdlib.h> — Includes standard library for malloc/free.", "code": "#include <stdlib.h>" },
    { "comment": "// struct Point { int x, y; }; — Defines a struct with two public members.", "code": "struct Point { int x, y; };" },
    { "comment": "// struct Point* create(int a, int b) { — Manual constructor-like function.", "code": "struct Point* create(int a, int b) {" },
    { "comment": "// struct Point* p = malloc(sizeof(struct Point)); — Allocates memory on heap.", "code": " struct Point* p = malloc(sizeof(struct Point));" },
    { "comment": "// p->x = a; p->y = b; return p; — Initializes and returns pointer.", "code": " p->x = a; p->y = b; return p;" },
    { "comment": "// } — End of create function.", "code": "}" },
    { "comment": "// void destroy(struct Point* p) { free(p); } — Manual destructor-like function.", "code": "void destroy(struct Point* p) { free(p); }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point* p = create(1, 2); — Calls manual init.", "code": " struct Point* p = create(1, 2);" },
    { "comment": "// printf(\"%d %d\\n\", p->x, p->y); — Prints members.", "code": " printf(\"%d %d\\n\", p->x, p->y);" },
    { "comment": "// destroy(p); — Calls manual cleanup.", "code": " destroy(p);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myctor.cpp — This is a C++ source file. In C++, constructors/destructors automate init/cleanup.", "code": "// myctor.cpp" },
    { "comment": "// class Point { int x, y; — Defines a class with private members.", "code": "class Point { int x, y;" },
    { "comment": "// public: Point(int a, int b) : x(a), y(b) {} — Constructor initializes members.", "code": " public: Point(int a, int b) : x(a), y(b) {}" },
    { "comment": "// ~Point() {} — Destructor for cleanup (empty here).", "code": " ~Point() {}" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// Point p(1, 2); — Calls constructor automatically.", "code": " Point p(1, 2);" },
    { "comment": "// Destructor called automatically on scope exit.", "code": " // Destructor called automatically." },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual risks leaks. C++ auto via ctor/dtor. Nuances: Init lists in C++. Implications: RAII prevents leaks, but virtual dtors needed for polymorphism.", "code": "/* Point p(1,2); // Auto init */" }
  ]
},
    {
  "title": "CHAPTER 8: Operator Overloading in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C no overloading; manual functions. C++ allows operator overload for natural syntax. Impact: Built-in-like custom types in C++. Nuances: Operator precedence.", "code": "" },
    { "comment": "// myop.c — This is a C source file. In C, operators cannot be overloaded; use functions.", "code": "// myop.c" },
    { "comment": "// struct Point { int x, y; }; — Defines a struct with two public members.", "code": "struct Point { int x, y; };" },
    { "comment": "// struct Point add(struct Point a, struct Point b) { — Manual addition function.", "code": "struct Point add(struct Point a, struct Point b) {" },
    { "comment": "// struct Point res = {a.x + b.x, a.y + b.y}; return res; — Computes and returns sum.", "code": " struct Point res = {a.x + b.x, a.y + b.y}; return res;" },
    { "comment": "// } — End of add function.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p1 = {1, 2}, p2 = {3, 4}; — Declares and initializes two structs.", "code": " struct Point p1 = {1, 2}, p2 = {3, 4};" },
    { "comment": "// struct Point sum = add(p1, p2); — Calls manual function.", "code": " struct Point sum = add(p1, p2);" },
    { "comment": "// printf(\"%d %d\\n\", sum.x, sum.y); — Prints result.", "code": " printf(\"%d %d\\n\", sum.x, sum.y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myop.cpp — This is a C++ source file. In C++, operators can be overloaded for custom types.", "code": "// myop.cpp" },
    { "comment": "// class Point { int x, y; — Defines a class with private members.", "code": "class Point { int x, y;" },
    { "comment": "// public: Point(int a, int b) : x(a), y(b) {} — Constructor.", "code": " public: Point(int a, int b) : x(a), y(b) {}" },
    { "comment": "// Point operator+(const Point& other) const { return Point(x + other.x, y + other.y); } — Overloads +.", "code": " Point operator+(const Point& other) const { return Point(x + other.x, y + other.y); }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// Point p1(1, 2), p2(3, 4); — Declares two objects.", "code": " Point p1(1, 2), p2(3, 4);" },
    { "comment": "// Point sum = p1 + p2; — Uses overloaded operator.", "code": " Point sum = p1 + p2;" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C requires functions for ops. C++ overloading makes syntax natural. Nuances: Const-correct overloads. Implications: Intuitive code, but misuse can lead to confusing operators.", "code": "/* Point p1(1,2), p2(3,4); Point sum = p1 + p2; */" }
  ]
},
    {
  "title": "CHAPTER 9: References (&) in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C uses pointers for reference semantics. C++ references safer/no null. Impact: Cleaner, safer in C++. Nuances: References non-reassignable.", "code": "" },
    { "comment": "// myref.c — This is a C source file. In C, references do not exist; use pointers for aliasing.", "code": "// myref.c" },
    { "comment": "// void swap(int* a, int* b) { — Defines function taking pointers for pass-by-reference simulation.", "code": "void swap(int* a, int* b) {" },
    { "comment": "// int temp = *a; *a = *b; *b = temp; — Swaps using dereferencing.", "code": " int temp = *a; *a = *b; *b = temp;" },
    { "comment": "// } — End of swap function.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int x = 1, y = 2; — Declares two integers.", "code": " int x = 1, y = 2;" },
    { "comment": "// swap(&x, &y); — Passes addresses explicitly.", "code": " swap(&x, &y);" },
    { "comment": "// printf(\"%d %d\\n\", x, y); — Prints swapped values.", "code": " printf(\"%d %d\\n\", x, y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myref.cpp — This is a C++ source file. In C++, references (&) provide safe aliasing.", "code": "// myref.cpp" },
    { "comment": "// void swap(int& a, int& b) { — Defines function taking references.", "code": "void swap(int& a, int& b) {" },
    { "comment": "// int temp = a; a = b; b = temp; — Swaps without dereferencing.", "code": " int temp = a; a = b; b = temp;" },
    { "comment": "// } — End of swap function.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int x = 1, y = 2; — Declares two integers.", "code": " int x = 1, y = 2;" },
    { "comment": "// swap(x, y); — Passes variables directly; references alias them.", "code": " swap(x, y);" },
    { "comment": "// std::cout << x << \" \" << y << \"\\n\"; — Prints swapped values.", "code": " std::cout << x << \" \" << y << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C pointers risk null/dangling. C++ references can't be null, cleaner. Nuances: References can't be reassigned. Implications: Safer code, but pointers still needed for dynamic memory.", "code": "/* int x=1,y=2; swap(x,y); */" }
  ]
},
    {
  "title": "CHAPTER 10: const Correctness in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C const weak/castable. C++ strong enforcement in methods. Impact: Compile-time bug catch in C++. Nuances: Mutable exceptions.", "code": "" },
    { "comment": "// myconst.c — This is a C source file. In C, const is weak; can be cast away.", "code": "// myconst.c" },
    { "comment": "// void print(const int* x) { — Function taking pointer to const int.", "code": "void print(const int* x) {" },
    { "comment": "// printf(\"%d\\n\", *x); — Prints value; can't modify through x, but const can be cast away.", "code": " printf(\"%d\\n\", *x);" },
    { "comment": "// } — End of print function.", "code": "}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int val = 42; print(&val); — Passes address to const pointer.", "code": " int val = 42; print(&val);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myconst.cpp — This is a C++ source file. In C++, const is strongly enforced.", "code": "// myconst.cpp" },
    { "comment": "// class Point { int x; — Defines a class with private member.", "code": "class Point { int x;" },
    { "comment": "// public: void set(int a) { x = a; } — Non-const method modifies member.", "code": " public: void set(int a) { x = a; }" },
    { "comment": "// int get() const { return x; } — Const method can't modify members.", "code": " int get() const { return x; }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// const Point p; p.get(); — Calls const method on const object.", "code": " const Point p; p.get();" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C const can be bypassed. C++ enforces at compile-time. Nuances: Const methods, mutable members. Implications: Prevents bugs, but requires careful design for const-correct APIs.", "code": "/* const Point p; p.get(); */" }
  ]
},
    {
  "title": "CHAPTER 11: new / delete vs malloc/free in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: malloc/free raw allocation. new/delete call ctors/dtors. Impact: Object integration in C++. Nuances: Array delete[].", "code": "" },
    { "comment": "// myalloc.c — This is a C source file. In C, use malloc/free for dynamic memory.", "code": "// myalloc.c" },
    { "comment": "// #include <stdlib.h> — Includes standard library for malloc/free.", "code": "#include <stdlib.h>" },
    { "comment": "// int* arr = malloc(10 * sizeof(int)); — Allocates raw memory for 10 ints.", "code": "int* arr = malloc(10 * sizeof(int));" },
    { "comment": "// free(arr); — Frees memory; no destructors called.", "code": "free(arr);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int* arr = malloc(10 * sizeof(int)); — Allocates memory.", "code": " int* arr = malloc(10 * sizeof(int));" },
    { "comment": "// free(arr); — Frees memory manually.", "code": " free(arr);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myalloc.cpp — This is a C++ source file. In C++, use new/delete for type-safe allocation.", "code": "// myalloc.cpp" },
    { "comment": "// int* arr = new int[10]; — Allocates and initializes (calls ctors).", "code": "int* arr = new int[10];" },
    { "comment": "// delete[] arr; — Frees and calls dtors.", "code": "delete[] arr;" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int* arr = new int[10]; — Allocates array.", "code": " int* arr = new int[10];" },
    { "comment": "// delete[] arr; — Frees array (use [] for arrays).", "code": " delete[] arr;" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: malloc/free raw. new/delete integrate with objects. Nuances: Array new requires delete[]. Implications: Safer in C++, but avoid raw pointers; use smart pointers.", "code": "/* Avoid mixing malloc/new. */" }
  ]
},
    {
  "title": "CHAPTER 12: Smart Pointers in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual malloc/free. C++ smart pointers auto-manage. Impact: Leak prevention in C++. Nuances: Unique vs shared.", "code": "" },
    { "comment": "// mysmart.c — This is a C source file. In C, manual memory management with malloc/free.", "code": "// mysmart.c" },
    { "comment": "// #include <stdlib.h> — Includes standard library for malloc/free.", "code": "#include <stdlib.h>" },
    { "comment": "// int* p = malloc(sizeof(int)); — Allocates memory for an int.", "code": "int* p = malloc(sizeof(int));" },
    { "comment": "// *p = 42; free(p); — Assigns value and frees memory manually.", "code": " *p = 42; free(p);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int* p = malloc(sizeof(int)); *p = 42; free(p); — Manual allocation and free.", "code": " int* p = malloc(sizeof(int)); *p = 42; free(p);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mysmart.cpp — This is a C++ source file. In C++, smart pointers automate memory management.", "code": "// mysmart.cpp" },
    { "comment": "// #include <memory> — Includes memory header for smart pointers.", "code": "#include <memory>" },
    { "comment": "// auto p = std::make_unique<int>(42); — Creates unique_ptr; auto-frees.", "code": "auto p = std::make_unique<int>(42);" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// auto p = std::make_unique<int>(42); — Allocates and initializes.", "code": " auto p = std::make_unique<int>(42);" },
    { "comment": "// std::cout << *p << \"\\n\"; — Accesses value.", "code": " std::cout << *p << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual frees risk leaks. C++ smart pointers auto-free. Nuances: unique_ptr exclusive, shared_ptr ref-counted. Implications: Leak prevention, but overhead for ref-counting.", "code": "/* Use unique_ptr or shared_ptr. */" }
  ]
},
    {
  "title": "CHAPTER 13: RAII in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual resource handling. C++ RAII auto via scope/dtors. Impact: Exception-safe in C++. Nuances: Custom wrappers.", "code": "" },
    { "comment": "// myraii.c — This is a C source file. In C, resources must be manually managed.", "code": "// myraii.c" },
    { "comment": "// #include <stdio.h> — Includes standard I/O for fopen/fclose.", "code": "#include <stdio.h>" },
    { "comment": "// FILE* f = fopen(\"file.txt\", \"r\"); — Opens file; manual handling.", "code": "FILE* f = fopen(\"file.txt\", \"r\");" },
    { "comment": "// if (f) fclose(f); — Closes file if open; manual.", "code": "if (f) fclose(f);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// FILE* f = fopen(\"file.txt\", \"r\"); if (f) fclose(f); — Manual open/close.", "code": " FILE* f = fopen(\"file.txt\", \"r\"); if (f) fclose(f);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myraii.cpp — This is a C++ source file. In C++, RAII auto-manages resources via dtors.", "code": "// myraii.cpp" },
    { "comment": "// #include <fstream> — Includes file stream for ifstream.", "code": "#include <fstream>" },
    { "comment": "// std::ifstream f(\"file.txt\"); — Opens file; auto-closes on scope exit.", "code": "std::ifstream f(\"file.txt\");" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::ifstream f(\"file.txt\"); — Constructor opens; dtor closes.", "code": " std::ifstream f(\"file.txt\");" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual management risks leaks. C++ RAII ensures cleanup. Nuances: Stack unwinding safe. Implications: Exception-safe code, but custom RAII classes needed for non-STL resources.", "code": "/* Wrap in classes for RAII. */" }
  ]
},
    {
  "title": "CHAPTER 14: Templates in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C macros for generics (unsafe). C++ templates type-safe/compile-time. Impact: Reusable code in C++. Nuances: Instantiation overhead.", "code": "" },
    { "comment": "// mytemplate.c — This is a C source file. In C, generics via macros (unsafe).", "code": "// mytemplate.c" },
    { "comment": "// #define ADD(T, a, b) ((T)(a) + (T)(b)) — Macro for addition; no type safety.", "code": "#define ADD(T, a, b) ((T)(a) + (T)(b))" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int sum = ADD(int, 1, 2); — Uses macro for ints.", "code": " int sum = ADD(int, 1, 2);" },
    { "comment": "// printf(\"%d\\n\", sum); — Prints result.", "code": " printf(\"%d\\n\", sum);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mytemplate.cpp — This is a C++ source file. In C++, templates provide safe generics.", "code": "// mytemplate.cpp" },
    { "comment": "// template <typename T> — Declares template parameter T.", "code": "template <typename T>" },
    { "comment": "// T add(T a, T b) { return a + b; } — Generic addition function.", "code": " T add(T a, T b) { return a + b; }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int sum = add<int>(1, 2); — Instantiates for int.", "code": " int sum = add<int>(1, 2);" },
    { "comment": "// std::cout << sum << \"\\n\"; — Prints result.", "code": " std::cout << sum << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C macros unsafe/no type check. C++ templates compile-time safe. Nuances: Specialization needed for edge cases. Implications: Metaprogramming, but template errors complex.", "code": "/* add<int>(1,2); add<double>(1.5,2.5); */" }
  ]
},
    {
  "title": "CHAPTER 15: STL Containers in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual data structures. C++ STL ready-made/dynamic. Impact: 80-90% less code in C++. Nuances: Overhead for small sizes.", "code": "" },
    { "comment": "// mycontainers.c — This is a C source file. In C, use manual arrays.", "code": "// mycontainers.c" },
    { "comment": "// double arr[10]; — Fixed-size array; no dynamic resizing.", "code": "double arr[10];" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// arr[0] = 1.0; — Assigns to first element.", "code": " arr[0] = 1.0;" },
    { "comment": "// printf(\"%f\\n\", arr[0]); — Prints first element.", "code": " printf(\"%f\\n\", arr[0]);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mycontainers.cpp — This is a C++ source file. In C++, use STL for dynamic containers.", "code": "// mycontainers.cpp" },
    { "comment": "// #include <vector> — Includes vector from STL.", "code": "#include <vector>" },
    { "comment": "// std::vector<double> v; v.push_back(1.0); — Dynamic array; auto-resizes.", "code": "std::vector<double> v; v.push_back(1.0);" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::vector<double> v; v.push_back(1.0); — Adds element.", "code": " std::vector<double> v; v.push_back(1.0);" },
    { "comment": "// std::cout << v[0] << \"\\n\"; — Accesses first element.", "code": " std::cout << v[0] << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual/fixed. C++ STL dynamic/safe. Nuances: STL overhead for small sizes. Implications: Productivity boost, but learn STL algorithms.", "code": "/* Use vector, map, etc. */" }
  ]
},
    {
  "title": "CHAPTER 16: Exceptions in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C error codes. C++ exceptions for separation. Impact: Clean paths in C++. Nuances: Overhead/unwinding.", "code": "" },
    { "comment": "// myexceptions.c — This is a C source file. In C, use error codes for handling.", "code": "// myexceptions.c" },
    { "comment": "// int func() { return -1; } — Returns error code.", "code": "int func() { return -1; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int result = func(); if (result == -1) printf(\"Error\\n\"); — Manual check.", "code": " int result = func(); if (result == -1) printf(\"Error\\n\");" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myexceptions.cpp — This is a C++ source file. In C++, use exceptions for handling.", "code": "// myexceptions.cpp" },
    { "comment": "// #include <stdexcept> — Includes exceptions.", "code": "#include <stdexcept>" },
    { "comment": "// void func() { throw std::runtime_error(\"Error\"); } — Throws exception.", "code": "void func() { throw std::runtime_error(\"Error\"); }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// try { func(); } catch (const std::exception& e) { std::cout << e.what() << \"\\n\"; } — Catches exception.", "code": " try { func(); } catch (const std::exception& e) { std::cout << e.what() << \"\\n\"; }" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C codes clutter code. C++ exceptions separate handling. Nuances: Overhead in exceptions. Implications: Cleaner normal paths, but stack unwinding needs RAII.", "code": "/* try { func(); } catch (...) {} */" }
  ]
},
    {
  "title": "CHAPTER 17: auto Type Deduction in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C limited auto (C23+). C++ powerful deduction for complex types. Impact: Less boilerplate in C++. Nuances: Trailing returns.", "code": "" },
    { "comment": "// myauto.c — This is a C source file. In C (C23+), auto is limited deduction.", "code": "// myauto.c" },
    { "comment": "// auto x = 42; — Deduce as int; limited to simple cases.", "code": "auto x = 42;" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// auto x = 42; printf(\"%d\\n\", x); — Uses deduced type.", "code": " auto x = 42; printf(\"%d\\n\", x);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myauto.cpp — This is a C++ source file. In C++, auto is powerful for complex types.", "code": "// myauto.cpp" },
    { "comment": "// #include <vector> — Includes vector for demo.", "code": "#include <vector>" },
    { "comment": "// auto x = std::vector<int>{1,2}; — Deduce as vector<int>.", "code": "auto x = std::vector<int>{1,2};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// auto x = std::vector<int>{1,2}; — Reduces boilerplate.", "code": " auto x = std::vector<int>{1,2};" },
    { "comment": "// for (auto e : x) std::cout << e << \" \"; — Auto in loop.", "code": " for (auto e : x) std::cout << e << \" \";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C limited auto. C++ powerful for templates/STL. Nuances: Trailing return types. Implications: Less typing, but over-use reduces readability.", "code": "/* Use auto for complex types. */" }
  ]
},
    {
  "title": "CHAPTER 18: Range-based For Loop in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C index loops manual. C++ range-for auto-iterates. Impact: Readable/safe in C++. Nuances: Copies vs refs.", "code": "" },
    { "comment": "// myrange.c — This is a C source file. In C, use index-based loops.", "code": "// myrange.c" },
    { "comment": "// int arr[3] = {1,2,3}; — Fixed array initialization.", "code": "int arr[3] = {1,2,3};" },
    { "comment": "// for(int i=0; i<3; i++) printf(\"%d\\n\", arr[i]); — Manual index loop.", "code": "for(int i=0; i<3; i++) printf(\"%d\\n\", arr[i]);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int arr[3] = {1,2,3}; for(int i=0; i<3; i++) printf(\"%d\\n\", arr[i]); — Loops with index.", "code": " int arr[3] = {1,2,3}; for(int i=0; i<3; i++) printf(\"%d\\n\", arr[i]);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myrange.cpp — This is a C++ source file. In C++, range-based for simplifies iteration.", "code": "// myrange.cpp" },
    { "comment": "// int arr[3] = {1,2,3}; — Array initialization.", "code": "int arr[3] = {1,2,3};" },
    { "comment": "// for(auto x : arr) std::cout << x << \"\\n\"; — Range loop.", "code": "for(auto x : arr) std::cout << x << \"\\n\";" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int arr[3] = {1,2,3}; for(auto x : arr) std::cout << x << \"\\n\"; — Simple iteration.", "code": " int arr[3] = {1,2,3}; for(auto x : arr) std::cout << x << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual indices risk errors. C++ range-for readable/safe. Nuances: Copies vs references. Implications: Works with STL; improves loop clarity.", "code": "/* Works with containers. */" }
  ]
},
    {
  "title": "CHAPTER 19: nullptr in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C NULL ambiguous macro. C++ nullptr typed keyword. Impact: Safer overloads in C++. Nuances: Pointer context only.", "code": "" },
    { "comment": "// mynull.c — This is a C source file. In C, use NULL for null pointers.", "code": "// mynull.c" },
    { "comment": "// void* p = NULL; — Assigns null; NULL is macro for 0 or (void*)0.", "code": "void* p = NULL;" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// void* p = NULL; if (p == NULL) printf(\"Null\\n\"); — Checks for null.", "code": " void* p = NULL; if (p == NULL) printf(\"Null\\n\");" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mynull.cpp — This is a C++ source file. In C++, use nullptr for typed null.", "code": "// mynull.cpp" },
    { "comment": "// void* p = nullptr; — Assigns typed null pointer.", "code": "void* p = nullptr;" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// void* p = nullptr; if (p == nullptr) std::cout << \"Null\\n\"; — Checks for null.", "code": " void* p = nullptr; if (p == nullptr) std::cout << \"Null\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C NULL ambiguous. C++ nullptr type-safe. Nuances: Better overloads. Implications: Prevents bugs in templates/pointers.", "code": "/* Better for overloads. */" }
  ]
},
    {
  "title": "CHAPTER 20: bool Type in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C bool via header (C99+). C++ built-in keyword. Impact: Clear logic in both, but C++ native.", "code": "" },
    { "comment": "// mybool.c — This is a C source file. In C (C99+), bool requires <stdbool.h>.", "code": "// mybool.c" },
    { "comment": "// #include <stdbool.h> — Includes bool/true/false macros.", "code": "#include <stdbool.h>" },
    { "comment": "// bool flag = true; — Uses bool; actually _Bool under the hood.", "code": "bool flag = true;" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// bool flag = true; if (flag) printf(\"True\\n\"); — Uses bool in conditional.", "code": " bool flag = true; if (flag) printf(\"True\\n\");" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mybool.cpp — This is a C++ source file. In C++, bool is built-in.", "code": "// mybool.cpp" },
    { "comment": "// bool flag = true; — Built-in bool with true/false keywords.", "code": "bool flag = true;" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// bool flag = true; if (flag) std::cout << \"True\\n\"; — Uses bool in conditional.", "code": " bool flag = true; if (flag) std::cout << \"True\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C optional via header. C++ built-in. Nuances: Bool size 1 byte. Implications: Clear logic, but implicit conversions from int.", "code": "/* Use true/false. */" }
  ]
},
    {
  "title": "CHAPTER 21: Name Mangling in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C no mangling. C++ mangles for overloading. Impact: C interop needs extern \"C\".", "code": "" },
    { "comment": "// mymangle.c — This is a C source file. In C, no name mangling; symbols are simple.", "code": "// mymangle.c" },
    { "comment": "// void func() {} — Defines function with plain name 'func'.", "code": "void func() {}" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(); — Calls function; symbol unchanged.", "code": " func();" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mymangle.cpp — This is a C++ source file. In C++, name mangling encodes types.", "code": "// mymangle.cpp" },
    { "comment": "// void func() {} — Compiler mangles name (e.g., _Z4funcv).", "code": "void func() {}" },
    { "comment": "// extern \"C\" void func_c() {} — Disables mangling for C compatibility.", "code": "extern \"C\" void func_c() {}" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(); func_c(); — Calls both.", "code": " func(); func_c();" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C simple symbols. C++ mangling for overloading. Nuances: Compiler-dependent mangling. Implications: extern \"C\" for interop; essential for libraries.", "code": "/* Use for C interop. */" }
  ]
},
    {
  "title": "CHAPTER 22: inline Functions in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C inline hint/weak. C++ stronger for headers/members. Impact: Optimization in C++. Nuances: ODR in C++.", "code": "" },
    { "comment": "// myinline.c — This is a C source file. In C (C99+), inline is a hint; weak semantics.", "code": "// myinline.c" },
    { "comment": "// inline int add(int a, int b) { return a + b; } — Suggests inlining; not enforced.", "code": "inline int add(int a, int b) { return a + b; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int sum = add(1, 2); — Calls inline function; may or may not be inlined.", "code": " int sum = add(1, 2);" },
    { "comment": "// printf(\"%d\\n\", sum); — Prints result.", "code": " printf(\"%d\\n\", sum);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myinline.cpp — This is a C++ source file. In C++, inline is stronger; common in headers.", "code": "// myinline.cpp" },
    { "comment": "// inline int add(int a, int b) { return a + b; } — Inline for optimization.", "code": "inline int add(int a, int b) { return a + b; }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int sum = add(1, 2); — Calls inline function; likely inlined.", "code": " int sum = add(1, 2);" },
    { "comment": "// std::cout << sum << \"\\n\"; — Prints result.", "code": " std::cout << sum << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C inline weak hint. C++ stronger for members/headers. Nuances: ODR violations. Implications: Better performance, but debug harder when inlined.", "code": "/* Use in headers. */" }
  ]
},
    {
  "title": "CHAPTER 23: Variable Length Arrays (VLA) in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C VLAs runtime-sized (C99+). C++ no VLAs; use vector. Impact: Portability in C++. Nuances: VLAs stack-allocated.", "code": "" },
    { "comment": "// myvla.c — This is a C source file. In C (C99+), VLAs allow runtime array sizes.", "code": "// myvla.c" },
    { "comment": "// void func(int n) { int arr[n]; } — Array size from runtime variable.", "code": "void func(int n) { int arr[n]; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(10); — Calls func with runtime size 10.", "code": " func(10);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myvla.cpp — This is a C++ source file. In C++, no VLAs; use vector.", "code": "// myvla.cpp" },
    { "comment": "// #include <vector> — Includes vector for dynamic arrays.", "code": "#include <vector>" },
    { "comment": "// void func(int n) { std::vector<int> arr(n); } — Dynamic size with vector.", "code": "void func(int n) { std::vector<int> arr(n); }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// func(10); — Calls func with runtime size 10.", "code": " func(10);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C VLAs flexible but non-portable. C++ vector safe/portable. Nuances: Vector heap. Implications: Avoid VLAs for cross-language.", "code": "/* Prefer vector in C++. */" }
  ]
},
    {
  "title": "CHAPTER 24: Designated Initializers in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C named init (C99+). C++ adopts in C++20. Impact: Readable inits in both. Nuances: Order independent.", "code": "" },
    { "comment": "// myinit.c — This is a C source file. In C (C99+), designated initializers for named member init.", "code": "// myinit.c" },
    { "comment": "// struct Point p = {.x=1, .y=2}; — Initializes members by name.", "code": "struct Point p = {.x=1, .y=2};" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p = {.x=1, .y=2}; printf(\"%d %d\\n\", p.x, p.y); — Uses designated init.", "code": " struct Point p = {.x=1, .y=2}; printf(\"%d %d\\n\", p.x, p.y);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myinit.cpp — This is a C++ source file. In C++ (C++20+), designated initializers supported.", "code": "// myinit.cpp" },
    { "comment": "// struct Point p{.x=1, .y=2}; — Initializes members by name.", "code": "struct Point p{.x=1, .y=2};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct Point p{.x=1, .y=2}; std::cout << p.x << \" \" << p.y << \"\\n\"; — Uses designated init.", "code": " struct Point p{.x=1, .y=2}; std::cout << p.x << \" \" << p.y << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C C99 feature for readability. C++20 adopts it. Nuances: Order independent. Implications: Safer init, but C++ aggregates only.", "code": "/* Use in modern code. */" }
  ]
},
    {
  "title": "CHAPTER 25: Big 1 - New Types Like Built-ins in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C structs + functions. C++ classes + overloading for built-in feel. Impact: Natural types in C++. Nuances: Operator rules.", "code": "" },
    { "comment": "// mytypes.c — This is a C source file. In C, structs + functions for custom types.", "code": "// mytypes.c" },
    { "comment": "// struct MyType { int val; }; — Defines a struct with public member.", "code": "struct MyType { int val; };" },
    { "comment": "// int add(MyType a, MyType b) { return a.val + b.val; } — Manual operation function.", "code": "int add(MyType a, MyType b) { return a.val + b.val; }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// struct MyType a = {1}, b = {2}; int sum = add(a, b); — Manual use.", "code": " struct MyType a = {1}, b = {2}; int sum = add(a, b);" },
    { "comment": "// printf(\"%d\\n\", sum); — Prints result.", "code": " printf(\"%d\\n\", sum);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mytypes.cpp — This is a C++ source file. In C++, classes with overloading for built-in-like behavior.", "code": "// mytypes.cpp" },
    { "comment": "// class MyType { public: int val; MyType(int v) : val(v) {} }; — Class with constructor.", "code": "class MyType { public: int val; MyType(int v) : val(v) {}" },
    { "comment": "// MyType operator+(const MyType& other) const { return MyType(val + other.val); } — Overloads +.", "code": " MyType operator+(const MyType& other) const { return MyType(val + other.val); }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// MyType a(1), b(2); MyType c = a + b; — Natural use like built-ins.", "code": " MyType a(1), b(2); MyType c = a + b;" },
    { "comment": "// std::cout << c.val << \"\\n\"; — Prints result.", "code": " std::cout << c.val << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual ops. C++ built-in-like. Nuances: Operator precedence. Implications: Intuitive types, but overloading can mislead.", "code": "/* MyType a(1), b(2); MyType c = a + b; */" },
    { "comment": "// Gain: Natural, self-documenting code. Pain relieved: No awkward functions.", "code": "/* Pain relieved: No more awkward function calls for ops. */" }
  ]
},
    {
  "title": "CHAPTER 26: Big 2 - RAII in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual free. C++ dtor auto-cleanup. Impact: Leak prevention in C++. Nuances: Scope-based.", "code": "" },
    { "comment": "// myraii.c — This is a C source file. In C, manual free for resources.", "code": "// myraii.c" },
    { "comment": "// void* p = malloc(100); — Allocates raw memory.", "code": "void* p = malloc(100);" },
    { "comment": "// /* Use p */ free(p); — Manual free required.", "code": "/* Use p */ free(p);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// void* p = malloc(100); /* Use p */ free(p); — Manual management.", "code": " void* p = malloc(100); /* Use p */ free(p);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myraii.cpp — This is a C++ source file. In C++, RAII via dtors.", "code": "// myraii.cpp" },
    { "comment": "// class Resource { void* data; public: Resource() { data = malloc(100); } ~Resource() { free(data); } }; — RAII class.", "code": "class Resource { void* data; public: Resource() { data = malloc(100); } ~Resource() { free(data); }" },
    { "comment": "// }; — Marks the end of the class definition.", "code": "};" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// { Resource r; } — Auto alloc in ctor, free in dtor.", "code": " { Resource r; }" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual leaks common. C++ auto cleanup. Nuances: Scope-based. Implications: Exception-safe, but custom classes needed.", "code": "/* { Resource r; } // Auto free */" },
    { "comment": "// Gain: Tied to lifetime. Pain relieved: No forgotten cleanups.", "code": "/* Pain relieved: No forgotten cleanups. */" }
  ]
},
    {
  "title": "CHAPTER 27: Big 3 - STL/Containers in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C manual structures. C++ STL dynamic. Impact: Less code/productivity in C++. Nuances: Capacity vs size.", "code": "" },
    { "comment": "// mystl.c — This is a C source file. In C, manual resize for arrays.", "code": "// mystl.c" },
    { "comment": "// int* arr = malloc(10 * sizeof(int)); — Manual allocation.", "code": "int* arr = malloc(10 * sizeof(int));" },
    { "comment": "// /* Manual resize */ free(arr); — Custom logic for resizing.", "code": "/* Manual resize */ free(arr);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int* arr = malloc(10 * sizeof(int)); /* Manual resize */ free(arr); — Manual handling.", "code": " int* arr = malloc(10 * sizeof(int)); /* Manual resize */ free(arr);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mystl.cpp — This is a C++ source file. In C++, vector auto-resizes.", "code": "// mystl.cpp" },
    { "comment": "// #include <vector> — Includes STL vector.", "code": "#include <vector>" },
    { "comment": "// std::vector<int> v; v.push_back(1); — Auto-resizes on push.", "code": "std::vector<int> v; v.push_back(1);" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::vector<int> v; v.push_back(1); — Adds; resizes if needed.", "code": " std::vector<int> v; v.push_back(1);" },
    { "comment": "// v.resize(100); — Explicit resize.", "code": " v.resize(100);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual 80-90% more code. C++ STL boosts productivity. Nuances: Vector capacity vs size. Implications: Safer, but small overhead.", "code": "/* v.resize(100); */" },
    { "comment": "// Gain: Focus on logic. Pain relieved: No custom structures.", "code": "/* Pain relieved: No more custom lists/arrays. */" }
  ]
},
    {
  "title": "CHAPTER 28: Big 4 - References + Const Correctness in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C pointers modifiable. C++ const refs prevent changes. Impact: Safer interfaces in C++. Nuances: Const propagation.", "code": "" },
    { "comment": "// myrefconst.c — This is a C source file. In C, use pointers; const weak.", "code": "// myrefconst.c" },
    { "comment": "// void func(double* ptr) { /* Can modify */ } — Pointer allows modification.", "code": "void func(double* ptr) { /* Can modify */ }" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// double x = 3.14; func(&x); — Passes pointer; modifiable.", "code": " double x = 3.14; func(&x);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myrefconst.cpp — This is a C++ source file. In C++, const refs safer.", "code": "// myrefconst.cpp" },
    { "comment": "// #include <vector> — Includes vector.", "code": "#include <vector>" },
    { "comment": "// void func(const std::vector<double>& v) { /* Can't modify */ } — Const ref prevents changes.", "code": "void func(const std::vector<double>& v) { /* Can't modify */ }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::vector<double> v{1.0}; func(v); — Passes const ref; safe.", "code": " std::vector<double> v{1.0}; func(v);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C pointers modifiable/null. C++ const refs safer. Nuances: Refs non-reassignable. Implications: Fewer bugs, but const propagation needed.", "code": "/* Safer interfaces. */" },
    { "comment": "// Gain: Compiler safety. Pain relieved: Fewer runtime bugs.", "code": "/* Pain relieved: Fewer runtime bugs. */" }
  ]
},
    {
  "title": "CHAPTER 29: Big 5 - Smart Pointers in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C raw pointers manual. C++ smart auto-manage. Impact: Clear ownership/leak rare in C++. Nuances: Unique/shared.", "code": "" },
    { "comment": "// mysmartpointer.c — This is a C source file. In C, raw pointers with manual delete.", "code": "// mysmartpointer.c" },
    { "comment": "// int* p = new int(42); — Allocates (C++ style for demo).", "code": "int* p = new int(42);" },
    { "comment": "// /* Use */ delete p; — Manual delete.", "code": "/* Use */ delete p;" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int* p = new int(42); delete p; — Manual management.", "code": " int* p = new int(42); delete p;" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mysmartpointer.cpp — This is a C++ source file. In C++, smart pointers auto-delete.", "code": "// mysmartpointer.cpp" },
    { "comment": "// #include <memory> — Includes memory for smart pointers.", "code": "#include <memory>" },
    { "comment": "// std::unique_ptr<int> p = std::make_unique<int>(42); — Auto-deletes.", "code": "std::unique_ptr<int> p = std::make_unique<int>(42);" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::unique_ptr<int> p = std::make_unique<int>(42); — Ownership clear.", "code": " std::unique_ptr<int> p = std::make_unique<int>(42);" },
    { "comment": "// std::cout << *p << \"\\n\"; — Accesses value.", "code": " std::cout << *p << \"\\n\";" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C raw leaks common. C++ smart rare leaks. Nuances: Unique exclusive, shared ref-counted. Implications: Clear ownership, but ref-count overhead.", "code": "/* Scope exit deletes. */" },
    { "comment": "// Gain: Safe memory. Pain relieved: No raw pointers.", "code": "/* Pain relieved: No raw pointers. */" }
  ]
},
    {
  "title": "CHAPTER 30: Big 6 - Templates/Generic Programming in C vs C++",
  "steps": [
    { "comment": "// Overall Difference: C macros unsafe/duplicative. C++ templates safe/reusable. Impact: Write once in C++. Nuances: Instantiation per type.", "code": "" },
    { "comment": "// mygeneric.c — This is a C source file. In C, generics via macros/copy-paste.", "code": "// mygeneric.c" },
    { "comment": "// #define ADD_INT(a,b) ((a) + (b)) — Macro for int addition.", "code": "#define ADD_INT(a,b) ((a) + (b))" },
    { "comment": "// #define ADD_DOUBLE(a,b) ((a) + (b)) — Duplicate macro for double.", "code": "#define ADD_DOUBLE(a,b) ((a) + (b))" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// int si = ADD_INT(1, 2); double sd = ADD_DOUBLE(1.5, 2.5); — Uses macros.", "code": " int si = ADD_INT(1, 2); double sd = ADD_DOUBLE(1.5, 2.5);" },
    { "comment": "// printf(\"%d %f\\n\", si, sd); — Prints results.", "code": " printf(\"%d %f\\n\", si, sd);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// mygeneric.cpp — This is a C++ source file. In C++, templates for generics.", "code": "// mygeneric.cpp" },
    { "comment": "// #include <vector> — Includes vector<T>.", "code": "#include <vector>" },
    { "comment": "// #include <span> — Includes span<T> (C++20).", "code": "#include <span>" },
    { "comment": "// template <typename T> void func(const std::span<T>& s) { /* Generic */ } — Template function.", "code": "template <typename T> void func(const std::span<T>& s) { /* Generic */ }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// std::vector<int> vi; std::vector<double> vd; — Uses for different types.", "code": " std::vector<int> vi; std::vector<double> vd;" },
    { "comment": "// func(std::span<int>(vi)); — Calls template for int.", "code": " func(std::span<int>(vi));" },
    { "comment": "// func(std::span<double>(vd)); — Calls for double.", "code": " func(std::span<double>(vd));" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C macros unsafe/duplicative. C++ templates safe/reusable. Nuances: Instantiation per type. Implications: Metaprogramming, but compile-time errors complex.", "code": "/* std::vector<int> vi; std::vector<double> vd; */" },
    { "comment": "// Gain: Write once for any type. Pain relieved: No macro hell.", "code": "/* Pain relieved: No macro hell. */" }
  ]
},
    {
  "title": "CHAPTER 31: Most Painful Jump - Manual to Modern C++",
  "steps": [
    { "comment": "// Overall Difference: C malloc/manual/errors. C++ smart/RAII/exceptions/STL. Impact: Safety/productivity in C++. Nuances: Learning curve.", "code": "" },
    { "comment": "// myjump.c — This is a C source file. In C, malloc/manual management/error codes.", "code": "// myjump.c" },
    { "comment": "// void* p = malloc(100); — Allocates raw memory.", "code": "void* p = malloc(100);" },
    { "comment": "// if (!p) return -1; — Error code for failure.", "code": "if (!p) return -1;" },
    { "comment": "// /* Use p */ free(p); — Manual cleanup.", "code": "/* Use p */ free(p);" },
    { "comment": "// int main() { — Entry point of the C program. Execution starts here.", "code": "int main() {" },
    { "comment": "// void* p = malloc(100); if (!p) return -1; free(p); — Manual with error code.", "code": " void* p = malloc(100); if (!p) return -1; free(p);" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// myjump.cpp — This is a C++ source file. In C++, unique_ptr/shared_ptr + RAII + exceptions + STL.", "code": "// myjump.cpp" },
    { "comment": "// #include <memory> — Includes smart pointers.", "code": "#include <memory>" },
    { "comment": "// #include <vector> — Includes STL vector.", "code": "#include <vector>" },
    { "comment": "// std::unique_ptr<int[]> p(new int[100]); — Smart ptr with RAII.", "code": "std::unique_ptr<int[]> p(new int[100]);" },
    { "comment": "// if (!p) throw std::bad_alloc(); — Throws exception on failure.", "code": "if (!p) throw std::bad_alloc();" },
    { "comment": "// std::vector<int> v(100); — STL alternative; auto-managed.", "code": "std::vector<int> v(100);" },
    { "comment": "// int process() { /* Use v or p */ return 0; } — Modern function.", "code": "int process() { /* Use v or p */ return 0; }" },
    { "comment": "// int main() { — Entry point of the C++ program. Execution starts here.", "code": "int main() {" },
    { "comment": "// try { std::unique_ptr<int[]> p(new int[100]); process(); } catch (...) {} — Exception-safe.", "code": " try { std::unique_ptr<int[]> p(new int[100]); process(); } catch (...) {}" },
    { "comment": "// return 0; — Returns 0 to the operating system, signaling successful program termination.", "code": " return 0;" },
    { "comment": "// } — End of the main function.", "code": "}" },
    { "comment": "// Impact: C manual/error-prone. C++ modern/safe. Nuances: Exceptions unwind stacks. Implications: Less leaks, but performance cost in exceptions.", "code": "/* Auto cleanup on scope exit. */" },
    { "comment": "// Note: Direction hurts based on habits/muscle memory.", "code": "/* Muscle memory shift is key. */" },
    { "comment": "// Welcome to std::vector & std::string — No more plain arrays! 😄", "code": "/* Good luck! */" }
  ]
}
  ];

  let currentChapter = 0;
  let currentStep = 0;

  const chapterList = document.getElementById('chapter-list');
  const chapterBtn = document.getElementById('chapter-btn');
  const codeArea = document.getElementById('code-area');
  const commentBox = document.getElementById('comment-box');
  const hintArea = document.getElementById('hint-area');
  const codeInput = document.getElementById('code-input');
  const submitBtn = document.getElementById('submit-btn');
  const skipBtn = document.getElementById('skip-btn');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const resetBtn = document.getElementById('reset');

  function populateChapters() {
    chapters.forEach((ch, idx) => {
      const item = document.createElement('div');
      item.classList.add('chapter-item');
      item.textContent = ch.title;
      item.onclick = () => loadChapter(idx);
      chapterList.appendChild(item);
    });
  }

  function loadChapter(chIdx) {
    currentChapter = chIdx;
    currentStep = 0;
    codeArea.innerHTML = '';
    commentBox.textContent = '';
    hintArea.textContent = 'Type exactly:';
    codeInput.value = '';
    chapterList.classList.remove('show');
    updateButtons();
    advanceStep();
  }

  function advanceStep() {
    if (currentStep < chapters[currentChapter].steps.length) {
      const step = chapters[currentChapter].steps[currentStep];
      commentBox.textContent = step.comment;
      hintArea.textContent = `Type exactly: ${step.code}`;
      codeInput.placeholder = step.code;
      codeInput.focus();
    } else {
      commentBox.textContent = 'Chapter complete! Move to next.';
      hintArea.textContent = '';
      codeInput.disabled = true;
      submitBtn.disabled = true;
      skipBtn.disabled = true;
    }
    updateButtons();
  }

  function addLine(code) {
    const line = document.createElement('div');
    line.classList.add('line', 'new');
    line.textContent = code;
    codeArea.appendChild(line);
    codeArea.scrollTop = codeArea.scrollHeight;
  }

  function checkInput() {
    const expected = chapters[currentChapter].steps[currentStep].code.trim();
    const input = codeInput.value.trim();
    if (input === expected) {
      addLine(input);
      currentStep++;
      codeInput.value = '';
      advanceStep();
    } else {
      codeInput.classList.add('shake');
      setTimeout(() => codeInput.classList.remove('shake'), 500);
    }
  }

  function skipStep() {
    const step = chapters[currentChapter].steps[currentStep];
    addLine(step.code);
    currentStep++;
    advanceStep();
  }

  function updateButtons() {
    prevBtn.disabled = currentChapter === 0;
    nextBtn.disabled = currentChapter === chapters.length - 1 || currentStep < chapters[currentChapter].steps.length;
  }

  chapterBtn.onclick = () => chapterList.classList.toggle('show');
  submitBtn.onclick = checkInput;
  skipBtn.onclick = skipStep;
  prevBtn.onclick = () => loadChapter(currentChapter - 1);
  nextBtn.onclick = () => loadChapter(currentChapter + 1);
  resetBtn.onclick = () => loadChapter(currentChapter);
  codeInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') checkInput(); });

  populateChapters();
  loadChapter(0);
</script>
</body>
</html>
